#BlueJ class context
comment0.target=Puzzle
comment1.params=rows\ cols
comment1.target=Puzzle(int,\ int)
comment10.params=
comment10.target=char[][]\ actualArrangement()
comment10.text=\r\n\ Devuelve\ una\ copia\ de\ la\ matriz\ actual\ de\ edici\u00F3n\ (starting),\r\n\ representando\ el\ estado\ actual\ del\ puzzle\ y\ pinta\ las\ baldosas.\r\n\ @return\ Una\ copia\ de\ la\ matriz\ starting.\r\n
comment11.params=
comment11.target=boolean\ ok()
comment12.params=
comment12.target=void\ exchange()
comment13.params=args
comment13.target=void\ main(java.lang.String[])
comment13.text=\ \ \ \r\n\ \ \ \ public\ void\ makeHole(int\ row,\ int\ column)\ {\r\n\ \ \ \ \ \ \ \ //\ Validar\ las\ coordenadas\r\n\ \ \ \ \ \ \ \ if\ (row\ >\=\ rows\ ||\ column\ >\=\ cols\ ||\ row\ <\ 0\ ||\ column\ <\ 0)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ showMessage("You\ have\ exceeded\ the\ puzzle\ space.",\ "Error");\r\n\ \ \ \ \ \ \ \ \ \ \ \ this.ok\ \=\ false;\ //\ Error\ Message\r\n\ \ \ \ \ \ \ \ \ \ \ \ return;\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \r\n\ \ \ \ \ \ \ \ Tile\ targetTile\ \=\ tiles.get(row).get(column);\r\n\ \ \ \ \r\n\ \ \ \ \ \ \ \ //\ Verificar\ si\ la\ celda\ est\u00E1\ vac\u00EDa\ y\ no\ tiene\ ya\ un\ agujero\r\n\ \ \ \ \ \ \ \ if\ (isTileEmpty(targetTile)\ &&\ \!targetTile.getIsHole())\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ int\ xPos\ \=\ targetTile.getXPos();\r\n\ \ \ \ \ \ \ \ \ \ \ \ int\ yPos\ \=\ targetTile.getYPos();\r\n\ \ \ \ \ \ \ \ \ \ \ \ int\ diameter\ \=\ tileSize;\r\n\ \ \ \ \r\n\ \ \ \ \ \ \ \ \ \ \ \ //\ Calcular\ la\ posici\u00F3n\ centrada\ del\ c\u00EDrculo\r\n\ \ \ \ \ \ \ \ \ \ \ \ int\ circleX\ \=\ xPos\ +\ (tileSize\ -\ diameter)\ /\ 2;\r\n\ \ \ \ \ \ \ \ \ \ \ \ int\ circleY\ \=\ yPos\ +\ (tileSize\ -\ diameter)\ /\ 2;\r\n\ \ \ \ \r\n\ \ \ \ \ \ \ \ \ \ \ \ //\ Crear\ y\ hacer\ visible\ el\ c\u00EDrculo\ (agujero)\r\n\ \ \ \ \ \ \ \ \ \ \ \ Circle\ hole\ \=\ new\ Circle(diameter,\ circleX,\ circleY,\ Color.WHITE);\r\n\ \ \ \ \ \ \ \ \ \ \ \ hole.makeVisible();\r\n\ \ \ \ \r\n\ \ \ \ \ \ \ \ \ \ \ \ //\ Marcar\ la\ baldosa\ como\ agujereada\r\n\ \ \ \ \ \ \ \ \ \ \ \ targetTile.setLabel('h');\r\n\ \ \ \ \ \ \ \ \ \ \ \ targetTile.setIsHole(true);\r\n\ \ \ \ \ \ \ \ \ \ \ \ this.ok\ \=\ true;\ //\ Acci\u00F3n\ exitosa\r\n\ \ \ \ \ \ \ \ }\ else\ if\ (targetTile.getIsHole())\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ showMessage("This\ tile\ already\ has\ a\ hole.",\ "Error");\r\n\ \ \ \ \ \ \ \ \ \ \ \ this.ok\ \=\ false;\ //\ Error\ message\r\n\ \ \ \ \ \ \ \ }\ else\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ showMessage("You\ can\ only\ make\ a\ hole\ in\ an\ empty\ tile.",\ "Error");\r\n\ \ \ \ \ \ \ \ \ \ \ \ this.ok\ \=\ false;\ //\ Error\ message\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ }\r\n\r\n\r\n\ \ \ \ \r\n\ \ \ \ //public\ int\ [][]\ fixedTiles(){\r\n\ \ \ \ \ \ \ \ //\ Al\ momento\ de\ hacer\ tilt,\ queremos\ que\ se\ tome\ una\ captura\ de\ la\ matriz\ antes\ y\ despues\ del\ tilt.\ La\ matriz\ con\ la\ configuracion\ antes\ del\ tilt\ me\ va\ a\ servir\ para\ comparar\ cuales\ fichas\ se\ movieron\ y\ cuales\ no\ al\ hacer\ tilt.\ Las\ que\ no\ se\ movieron\ es\ porque\ no\ se\ puede.\ Entonces,\ las\ que\ mantienen\ la\ misma\ posici\u00F3n\ en\ la\ nueva\ matriz\ despues\ de\ tilt,\ que\ las\ de\ antes\ de\ tilt,\ van\ a\ ser\ mis\ baldosas\ atascadas,\ las\ vamos\ a\ marcar\ y\ luego\ las\ vamos\ a\ hacer\ titilar.\ \r\n\r\n\ \ \ \ \ \ \ \ //\ requisito,\ hacer\ que\ funcione\ el\ tilt\ de\ forma\ correcta\ y\ que\ al\ hacer\ tilt\ sobre\ un\ conjunto\ de\ fichas\ pegadas,\ s\u00ED\ se\ muevan\ si\ se\ pueden\ mover,\ no\ que\ toque\ hacer\ doble\ vez\ tilt\ para\ que\ si\ se\ muevan.\ \r\n\ \ \ \ //}\r\n\r\n\ \ \ \ //\ I\ used\ the\ same\ logic\ that\ method\ isGoal\ about\ comparing\ and\ to\ get\ the\ position\ on\ the\ tile\ with\ the\ label.\r\n\ \ \ \ public\ int\ misplacedTiles(){\r\n\ \ \ \ \ \ \ \ \r\n\ \ \ \ \ \ \ \ int\ cont\ \=\ 0;\r\n\ \ \ \ \ \ \ \ \r\n\ \ \ \ \ \ \ \ for\ (int\ row\ \=\ 0;\ row\ <\ rows;row++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ for\ (int\ col\ \=\ 0;\ col\ <\ cols;col++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Tile\ currentTile\ \=\ tiles.get(row).get(col);\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ char\ currentLabel\ \=\ currentTile.getLabel();\r\n\ \ \ \ \r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Tile\ referingTile\ \=\ referingTiles.get(row).get(col);\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ char\ referenceLabel\ \=\ referingTile.getLabel();\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if\ (currentLabel\ \!\=\ referenceLabel\ &&\ currentLabel\ \!\=\ '*'){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ cont++;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \r\n\ \ \ \ \ \ \ \ return\ cont;\r\n\ \ \ \ }\r\n\r\n
comment2.params=starting\ ending
comment2.target=Puzzle(char[][],\ char[][])
comment3.params=coords
comment3.target=boolean\ areValidCoordinates(int[])
comment3.text=\ \ \ public\ void\ relocateTileMovement(Tile\ fromTile,\ Tile\ toTile,\ int[]\ from,\ int[]\ to)\ {\r\n\ \ \ \ \ \ \ \ //\ Mover\ la\ instancia\ de\ la\ baldosa\ visualmente\r\n\ \ \ \ \ \ \ \ fromTile.moveHorizontal((to[1]\ -\ from[1])\ *\ (tileSize\ +\ margin));\r\n\ \ \ \ \ \ \ \ fromTile.moveVertical((to[0]\ -\ from[0])\ *\ (tileSize\ +\ margin));\r\n\ \ \ \ \ \ \ \ //\ Actualizar\ la\ lista\ de\ baldosas\:\ mover\ la\ baldosa\ a\ la\ nueva\ posici\u00F3n\r\n\ \ \ \ \ \ \ \ tiles.get(to[0]).set(to[1],\ fromTile);\r\n\ \ \ \ \ \ \ \ //\ Crear\ una\ nueva\ baldosa\ vac\u00EDa\ en\ la\ posici\u00F3n\ original\r\n\ \ \ \ \ \ \ \ Tile\ emptyTile\ \=\ createEmptyTile(from[0],\ from[1]);\r\n\ \ \ \ \ \ \ \ tiles.get(from[0]).set(from[1],\ emptyTile);\r\n}*
comment4.params=
comment4.target=boolean\ isGoal()
comment4.text=\ \ \ //\ Movimiento\ hacia\ abajo\r\n\ \ \ \ private\ int\ calculateMaxMoveDown(int\ row,\ int\ col,\ List<Tile>\ group)\ {\r\n\ \ \ \ \ \ \ \ int\ maxMove\ \=\ 0;\r\n\ \ \ \ \ \ \ \ for\ (int\ i\ \=\ row\ +\ 1;\ i\ <\ rows;\ i++)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ Tile\ nextTile\ \=\ getTileAtPosition(i,\ col);\r\n\ \ \ \ \ \ \ \ \ \ \ \ if\ (isTileEmpty(nextTile)\ ||\ (group\ \!\=\ null\ &&\ group.contains(nextTile)))\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ maxMove++;\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\ else\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break;\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ return\ maxMove;\r\n\ \ \ \ }\r\n\r\n\ \ \ \ private\ int\ calculateMaxMoveDownGroup(List<Tile>\ group)\ {\r\n\ \ \ \ \ \ \ \ int\ maxMove\ \=\ rows;\r\n\ \ \ \ \ \ \ \ for\ (Tile\ tile\ \:\ group)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ int\ tileMaxMove\ \=\ calculateMaxMoveDown(tile.getRow(),\ tile.getCol(),\ group);\r\n\ \ \ \ \ \ \ \ \ \ \ \ maxMove\ \=\ Math.min(maxMove,\ tileMaxMove);\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ return\ maxMove;\r\n\ \ \ \ }\r\n\r\n\ /**\ \ \ private\ void\ moveTileDown(Tile\ tile,\ int\ steps)\ {\r\n\ \ \ \ \ \ \ \ if\ (steps\ \=\=\ 0)\ return;\r\n\ \ \ \ \ \ \ \ int\ newRow\ \=\ tile.getRow()\ +\ steps;\r\n\ \ \ \ \ \ \ \ tile.moveVertical(steps\ *\ (tileSize\ +\ margin));\r\n\ \ \ \ \ \ \ \ tiles.get(tile.getRow()).set(tile.getCol(),\ createEmptyTile(tile.getRow(),\ tile.getCol()));\r\n\ \ \ \ \ \ \ \ tiles.get(newRow).set(tile.getCol(),\ tile);\r\n\ \ \ \ \ \ \ \ tile.setRow(newRow);\r\n\ \ \ \ }\r\n\r\n\ \ \ \ private\ void\ moveGroupDown(List<Tile>\ group,\ int\ steps)\ {\r\n\ \ \ \ \ \ \ \ if\ (steps\ \=\=\ 0)\ return;\r\n\ \ \ \ \ \ \ \ //\ Ordenar\ el\ grupo\ para\ que\ las\ baldosas\ inferiores\ se\ muevan\ primero\r\n\ \ \ \ \ \ \ \ group.sort((t1,\ t2)\ ->\ Integer.compare(t2.getRow(),\ t1.getRow()));\r\n\ \ \ \ \ \ \ \ //\ Eliminar\ baldosas\ de\ sus\ posiciones\ antiguas\r\n\ \ \ \ \ \ \ \ for\ (Tile\ tile\ \:\ group)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ tiles.get(tile.getRow()).set(tile.getCol(),\ createEmptyTile(tile.getRow(),\ tile.getCol()));\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ //\ Mover\ baldosas\ a\ sus\ nuevas\ posiciones\r\n\ \ \ \ \ \ \ \ for\ (Tile\ tile\ \:\ group)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ int\ newRow\ \=\ tile.getRow()\ +\ steps;\r\n\ \ \ \ \ \ \ \ \ \ \ \ tile.moveVertical(steps\ *\ (tileSize\ +\ margin));\r\n\ \ \ \ \ \ \ \ \ \ \ \ tiles.get(newRow).set(tile.getCol(),\ tile);\r\n\ \ \ \ \ \ \ \ \ \ \ \ tile.setRow(newRow);\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ }\r\n\r\n\ \ \ \ //\ Movimiento\ hacia\ la\ derecha\r\n\ \ \ \ private\ int\ calculateMaxMoveRight(int\ row,\ int\ col,\ List<Tile>\ group)\ {\r\n\ \ \ \ \ \ \ \ int\ maxMove\ \=\ 0;\r\n\ \ \ \ \ \ \ \ for\ (int\ i\ \=\ col\ +\ 1;\ i\ <\ cols;\ i++)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ Tile\ nextTile\ \=\ getTileAtPosition(row,\ i);\r\n\ \ \ \ \ \ \ \ \ \ \ \ if\ (isTileEmpty(nextTile)\ ||\ (group\ \!\=\ null\ &&\ group.contains(nextTile)))\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ maxMove++;\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\ else\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break;\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ return\ maxMove;\r\n\ \ \ \ }\r\n\r\n\ \ \ \ private\ int\ calculateMaxMoveRightGroup(List<Tile>\ group)\ {\r\n\ \ \ \ \ \ \ \ int\ maxMove\ \=\ cols;\r\n\ \ \ \ \ \ \ \ for\ (Tile\ tile\ \:\ group)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ int\ tileMaxMove\ \=\ calculateMaxMoveRight(tile.getRow(),\ tile.getCol(),\ group);\r\n\ \ \ \ \ \ \ \ \ \ \ \ maxMove\ \=\ Math.min(maxMove,\ tileMaxMove);\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ return\ maxMove;\r\n\ \ \ \ }\r\n\r\n\ \ \ \ private\ void\ moveTileRight(Tile\ tile,\ int\ steps)\ {\r\n\ \ \ \ \ \ \ \ if\ (steps\ \=\=\ 0)\ return;\r\n\ \ \ \ \ \ \ \ int\ newCol\ \=\ tile.getCol()\ +\ steps;\r\n\ \ \ \ \ \ \ \ tile.moveHorizontal(steps\ *\ (tileSize\ +\ margin));\r\n\ \ \ \ \ \ \ \ tiles.get(tile.getRow()).set(tile.getCol(),\ createEmptyTile(tile.getRow(),\ tile.getCol()));\r\n\ \ \ \ \ \ \ \ tiles.get(tile.getRow()).set(newCol,\ tile);\r\n\ \ \ \ \ \ \ \ tile.setCol(newCol);\r\n\ \ \ \ }\r\n\r\n\ \ \ \ private\ void\ moveGroupRight(List<Tile>\ group,\ int\ steps)\ {\r\n\ \ \ \ \ \ \ \ if\ (steps\ \=\=\ 0)\ return;\r\n\ \ \ \ \ \ \ \ //\ Ordenar\ el\ grupo\ para\ que\ las\ baldosas\ con\ columnas\ m\u00E1s\ altas\ se\ muevan\ primero\r\n\ \ \ \ \ \ \ \ group.sort((t1,\ t2)\ ->\ Integer.compare(t2.getCol(),\ t1.getCol()));\r\n\ \ \ \ \ \ \ \ //\ Eliminar\ baldosas\ de\ sus\ posiciones\ antiguas\r\n\ \ \ \ \ \ \ \ for\ (Tile\ tile\ \:\ group)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ tiles.get(tile.getRow()).set(tile.getCol(),\ createEmptyTile(tile.getRow(),\ tile.getCol()));\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ //\ Mover\ baldosas\ a\ sus\ nuevas\ posiciones\r\n\ \ \ \ \ \ \ \ for\ (Tile\ tile\ \:\ group)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ int\ newCol\ \=\ tile.getCol()\ +\ steps;\r\n\ \ \ \ \ \ \ \ \ \ \ \ tile.moveHorizontal(steps\ *\ (tileSize\ +\ margin));\r\n\ \ \ \ \ \ \ \ \ \ \ \ tiles.get(tile.getRow()).set(newCol,\ tile);\r\n\ \ \ \ \ \ \ \ \ \ \ \ tile.setCol(newCol);\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ }\r\n\r\n\ \ \ \ //\ Movimiento\ hacia\ la\ izquierda\r\n\ \ \ \ private\ int\ calculateMaxMoveLeft(int\ row,\ int\ col,\ List<Tile>\ group)\ {\r\n\ \ \ \ \ \ \ \ int\ maxMove\ \=\ 0;\r\n\ \ \ \ \ \ \ \ for\ (int\ i\ \=\ col\ -\ 1;\ i\ >\=\ 0;\ i--)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ Tile\ nextTile\ \=\ getTileAtPosition(row,\ i);\r\n\ \ \ \ \ \ \ \ \ \ \ \ if\ (isTileEmpty(nextTile)\ ||\ (group\ \!\=\ null\ &&\ group.contains(nextTile)))\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ maxMove++;\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\ else\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break;\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ return\ maxMove;\r\n\ \ \ \ }\r\n\r\n\ \ \ \ private\ int\ calculateMaxMoveLeftGroup(List<Tile>\ group)\ {\r\n\ \ \ \ \ \ \ \ int\ maxMove\ \=\ cols;\r\n\ \ \ \ \ \ \ \ for\ (Tile\ tile\ \:\ group)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ int\ tileMaxMove\ \=\ calculateMaxMoveLeft(tile.getRow(),\ tile.getCol(),\ group);\r\n\ \ \ \ \ \ \ \ \ \ \ \ maxMove\ \=\ Math.min(maxMove,\ tileMaxMove);\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ return\ maxMove;\r\n\ \ \ \ }\r\n\r\n\ \ \ \ private\ void\ moveTileLeft(Tile\ tile,\ int\ steps)\ {\r\n\ \ \ \ \ \ \ \ if\ (steps\ \=\=\ 0)\ return;\r\n\ \ \ \ \ \ \ \ int\ newCol\ \=\ tile.getCol()\ -\ steps;\r\n\ \ \ \ \ \ \ \ tile.moveHorizontal(-steps\ *\ (tileSize\ +\ margin));\r\n\ \ \ \ \ \ \ \ tiles.get(tile.getRow()).set(tile.getCol(),\ createEmptyTile(tile.getRow(),\ tile.getCol()));\r\n\ \ \ \ \ \ \ \ tiles.get(tile.getRow()).set(newCol,\ tile);\r\n\ \ \ \ \ \ \ \ tile.setCol(newCol);\r\n\ \ \ \ }\r\n\r\n\ \ \ \ private\ void\ moveGroupLeft(List<Tile>\ group,\ int\ steps)\ {\r\n\ \ \ \ \ \ \ \ if\ (steps\ \=\=\ 0)\ return;\r\n\ \ \ \ \ \ \ \ //\ Ordenar\ el\ grupo\ para\ que\ las\ baldosas\ con\ columnas\ m\u00E1s\ bajas\ se\ muevan\ primero\r\n\ \ \ \ \ \ \ \ group.sort((t1,\ t2)\ ->\ Integer.compare(t1.getCol(),\ t2.getCol()));\r\n\ \ \ \ \ \ \ \ //\ Eliminar\ baldosas\ de\ sus\ posiciones\ antiguas\r\n\ \ \ \ \ \ \ \ for\ (Tile\ tile\ \:\ group)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ tiles.get(tile.getRow()).set(tile.getCol(),\ createEmptyTile(tile.getRow(),\ tile.getCol()));\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ //\ Mover\ baldosas\ a\ sus\ nuevas\ posiciones\r\n\ \ \ \ \ \ \ \ for\ (Tile\ tile\ \:\ group)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ int\ newCol\ \=\ tile.getCol()\ -\ steps;\r\n\ \ \ \ \ \ \ \ \ \ \ \ tile.moveHorizontal(-steps\ *\ (tileSize\ +\ margin));\r\n\ \ \ \ \ \ \ \ \ \ \ \ tiles.get(tile.getRow()).set(newCol,\ tile);\r\n\ \ \ \ \ \ \ \ \ \ \ \ tile.setCol(newCol);\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ }\r\n\r\n\ \ \ \ //\ M\u00E9todo\ para\ recolectar\ todas\ las\ baldosas\ en\ un\ grupo\ pegado\r\n\ \ \ \ private\ void\ collectStuckGroup(Tile\ tile,\ List<Tile>\ group)\ {\r\n\ \ \ \ \ \ \ \ if\ (tile.isVisited())\ return;\r\n\ \ \ \ \ \ \ \ tile.setVisited(true);\r\n\ \ \ \ \ \ \ \ group.add(tile);\r\n\ \ \ \ \ \ \ \ int\ row\ \=\ tile.getRow();\r\n\ \ \ \ \ \ \ \ int\ col\ \=\ tile.getCol();\r\n\ \ \ \ \ \ \ \ int[][]\ directions\ \=\ {\ {\ -1,\ 0\ },\ {\ 1,\ 0\ },\ {\ 0,\ -1\ },\ {\ 0,\ 1\ }\ };\r\n\ \ \ \ \ \ \ \ for\ (int[]\ dir\ \:\ directions)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ int\ adjRow\ \=\ row\ +\ dir[0];\r\n\ \ \ \ \ \ \ \ \ \ \ \ int\ adjCol\ \=\ col\ +\ dir[1];\r\n\ \ \ \ \ \ \ \ \ \ \ \ Tile\ adjacentTile\ \=\ getTileAtPosition(adjRow,\ adjCol);\r\n\ \ \ \ \ \ \ \ \ \ \ \ if\ (adjacentTile\ \!\=\ null\ &&\ \!adjacentTile.isVisited()\ &&\ \!isTileEmpty(adjacentTile)\ &&\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (adjacentTile.isStuck()\ ||\ adjacentTile.hasGlue()))\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ collectStuckGroup(adjacentTile,\ group);\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ }\r\n\r\n\ \ \ \ //\ M\u00E9todo\ para\ crear\ una\ baldosa\ vac\u00EDa\r\n\ \ \ \ private\ Tile\ createEmptyTile(int\ row,\ int\ col)\ {\r\n\ \ \ \ \ \ \ \ int\ xPosition\ \=\ 105\ +\ (col\ *\ (tileSize\ +\ margin));\r\n\ \ \ \ \ \ \ \ int\ yPosition\ \=\ 55\ +\ (row\ *\ (tileSize\ +\ margin));\r\n\ \ \ \ \ \ \ \ Tile\ emptyTile\ \=\ new\ Tile(tileSize,\ '*',\ xPosition,\ yPosition,\ padding,\ row,\ col);\r\n\ \ \ \ \ \ \ \ return\ emptyTile;\r\n\ \ \ \ }\r\n\r\n\ \ \ \ //\ M\u00E9todo\ para\ obtener\ una\ baldosa\ en\ una\ posici\u00F3n\ espec\u00EDfica\r\n\ \ \ \ private\ Tile\ getTileAtPosition(int\ row,\ int\ col)\ {\r\n\ \ \ \ \ \ \ \ if\ (row\ >\=\ 0\ &&\ row\ <\ rows\ &&\ col\ >\=\ 0\ &&\ col\ <\ cols)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ return\ tiles.get(row).get(col);\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ return\ null;\r\n\ \ \ \ }\r\n\r\n\ \ \ \ //\ M\u00E9todo\ para\ verificar\ si\ una\ baldosa\ est\u00E1\ vac\u00EDa\ (basado\ en\ el\ color\ lightBrown)\r\n\ \ \ \ private\ boolean\ isTileEmpty(Tile\ tile)\ {\r\n\ \ \ \ \ \ \ \ return\ tile.getTileColor().equals(lightBrown);\r\n\ \ \ \ }\r\n\r\n\ \ \ \ //\ Resetear\ las\ banderas\ de\ visitado\ despu\u00E9s\ de\ la\ inclinaci\u00F3n\r\n\ \ \ \ private\ void\ resetVisitedFlags()\ {\r\n\ \ \ \ \ \ \ \ for\ (List<Tile>\ rowList\ \:\ tiles)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ for\ (Tile\ tile\ \:\ rowList)\ {\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tile.setVisited(false);\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ }\r\n\ \ \ \ \r\n\ \ \ \ //\ Muestra\ un\ mensaje\ de\ error\ si\ el\ simulador\ es\ visible\ y\ cambia\ el\ estado\ de\ ok\ a\ false\r\n\ \ \ \ public\ void\ showMessage(String\ message,\ String\ title){\r\n\ \ \ \ \ \ \ \ if(this.visible){\r\n\ \ \ \ \ \ \ \ \ \ \ \ JOptionPane.showMessageDialog(null,message,title,JOptionPane.ERROR_MESSAGE);\r\n\ \ \ \ \ \ \ \ \ \ \ \ this.ok\ \=\ false;\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ }\r\n
comment5.params=
comment5.target=void\ makeVisibleTiles()
comment6.params=
comment6.target=void\ makeVisibleRectangle()
comment7.params=
comment7.target=void\ makeInvisibleTiles()
comment8.params=
comment8.target=void\ makeInvisibleRectangle()
comment9.params=
comment9.target=void\ finish()
numComments=14
